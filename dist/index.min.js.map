{"version":3,"file":"index.min.js","sources":["index.js"],"sourcesContent":["function asserthtmlelement(ele) {\n    if (!(ele instanceof Element)) {\n        console.error(ele);\n        console.error(\"invalid HTMLElement!\");\n        throw TypeError();\n    }\n}\n\nconst acceptValue = [ \"input\", \"textarea\", \"option\", \"select\" ];\n\nvar mustUseDomProp = (tag, attr, attrtype) => attr === \"value\" && acceptValue.includes(tag) && attrtype !== \"button\" || attr === \"selected\" && tag === \"option\" || attr === \"checked\" && tag === \"input\" || attr === \"muted\" && tag === \"video\";\n\nfunction isArray(a) {\n    return Array.isArray(a);\n}\n\nfunction isstring(a) {\n    return typeof a === \"string\";\n}\n\nfunction isobject(a) {\n    return typeof a === \"object\" && a !== null;\n}\n\nfunction isSet(a) {\n    return a instanceof Set;\n}\n\nfunction geteletagname(ele) {\n    return ele.tagName.toLowerCase();\n}\n\nconst String = window.String;\n\nconst Reflect$1 = window.Reflect;\n\nconst {get: get, set: set, ownKeys: ownKeys} = Reflect$1;\n\nconst valuestring = \"value\";\n\nconst isinputcheckbox = ele => \"input\" === geteletagname(ele) && (get(ele, \"type\") === \"checkbox\" || get(ele, \"type\") === \"radio\");\n\nconst hyphenateRE = /\\B([A-Z])/g;\n\nconst hyphenate = str => str.replace(hyphenateRE, \"-$1\").toLowerCase();\n\nfunction objtostylestring(obj) {\n    obj = JSON.parse(JSON.stringify(obj));\n    const objentries = Object.entries(obj).map(([key, value]) => [ hyphenate(key).trim(), value ]);\n    return objentries.map(([key, value]) => key + \":\" + value).join(\";\");\n}\n\nfunction attributesownkeys(ele) {\n    return ele.getAttributeNames();\n}\n\nfunction getattribute(ele, key) {\n    return ele.getAttribute(key);\n}\n\nfunction setattribute(ele, key, value) {\n    return ele.setAttribute(key, value);\n}\n\nfunction removeAttribute(ele, key) {\n    return ele.removeAttribute(key);\n}\n\nfunction isinputtextortextarea(ele) {\n    const tagname = geteletagname(ele);\n    return tagname === \"textarea\" || tagname === \"select\" || tagname === \"input\" && get(ele, \"type\") === \"text\";\n}\n\nfunction hasAttribute(ele, key) {\n    return ele.hasAttribute(key);\n}\n\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\n\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\n\nvar _ele;\n\nclass Attrhandler {\n    constructor(ele) {\n        _ele.set(this, void 0);\n        __classPrivateFieldSet(this, _ele, ele);\n        const proto = Attrhandler.prototype;\n        Reflect.ownKeys(proto).forEach(k => {\n            let f = get(proto, k);\n            if (typeof f == \"function\") {\n                set(this, k, f.bind(this));\n            }\n        });\n    }\n    ownKeys() {\n        const ele = __classPrivateFieldGet(this, _ele);\n        const isinputtextortextareaflag = isinputtextortextarea(ele);\n        const keys = attributesownkeys(ele);\n        return Array.from(new Set([ ...keys, isinputcheckbox(ele) ? \"checked\" : undefined, isinputtextortextareaflag ? valuestring : undefined ].flat(Infinity).filter(a => !!a)));\n    }\n    get(_target, key) {\n        const ele = __classPrivateFieldGet(this, _ele);\n        if (mustUseDomProp(geteletagname(ele), String(key), get(ele, \"type\"))) {\n            return get(ele, String(key));\n        } else {\n            const v = getattribute(ele, String(key));\n            if (v === \"\") {\n                return true;\n            }\n            if (v === null) {\n                return;\n            }\n            if (isstring(v)) {\n                try {\n                    return JSON.parse(String(v));\n                } catch (error) {\n                    return v;\n                }\n            } else return;\n        }\n    }\n    set(_t, key, v) {\n        const ele = __classPrivateFieldGet(this, _ele);\n        if (\"function\" === typeof v) {\n            console.error(v);\n            console.error(\"Setting properties as functions is not allowed\");\n            throw TypeError();\n        }\n        if (mustUseDomProp(geteletagname(ele), String(key), get(ele, \"type\"))) {\n            return set(ele, String(key), v);\n        } else if (key === \"style\") {\n            const csstext = isstring(v) ? v : isobject(v) ? objtostylestring(v) : String(v);\n            set(get(ele, \"style\"), \"cssText\", csstext.trim());\n            return true;\n        } else if (key === \"class\" && isobject(v)) {\n            const classtext = isArray(v) ? v.join(\" \") : isSet(v) ? [ ...v ].join(\" \") : String(v);\n            setattribute(ele, String(key), classtext);\n            return true;\n        } else {\n            if (false === v || v === null || v === undefined) {\n                removeAttribute(ele, String(key));\n                return true;\n            }\n            if (isSet(v)) {\n                setattribute(ele, String(key), JSON.stringify([ ...v ]));\n                return true;\n            } else {\n                if (v === true) {\n                    v = \"\";\n                }\n                setattribute(ele, String(key), isobject(v) ? JSON.stringify(v) : String(v));\n                return true;\n            }\n        }\n    }\n    deleteProperty(_t, k) {\n        const ele = __classPrivateFieldGet(this, _ele);\n        removeAttribute(ele, String(k));\n        return true;\n    }\n    has(_target, key) {\n        const ele = __classPrivateFieldGet(this, _ele);\n        return hasAttribute(ele, String(key));\n    }\n    defineProperty() {\n        return false;\n    }\n    getOwnPropertyDescriptor(_target, key) {\n        const ele = __classPrivateFieldGet(this, _ele);\n        const otherdescipter = {\n            enumerable: true,\n            configurable: true,\n            writable: true\n        };\n        const myvalue = getattribute(ele, String(key));\n        if (typeof myvalue !== \"undefined\") {\n            return {\n                value: myvalue,\n                ...otherdescipter\n            };\n        } else {\n            return;\n        }\n    }\n    setPrototypeOf() {\n        return false;\n    }\n}\n\n_ele = new WeakMap;\n\nfunction createeleattragentreadwrite(ele) {\n    asserthtmlelement(ele);\n    const cached = elementtoproxy.get(ele);\n    if (cached) {\n        return cached;\n    }\n    var temp = Object.create(null);\n    const handler = new Attrhandler(ele);\n    const outputattrs = new Proxy(temp, handler);\n    elementtoproxy.set(ele, outputattrs);\n    return outputattrs;\n}\n\nconst elementtoproxy = new WeakMap;\n\nexport default createeleattragentreadwrite;\n//# sourceMappingURL=index.js.map\n"],"names":["ele","Element","TypeError"],"mappings":"u9EAAkCA,QACxBA,aAAeC,eAGXC"}